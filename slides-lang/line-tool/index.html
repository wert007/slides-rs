<html>
            <head>
            <link href="style.css" rel="stylesheet"/>
            <script src="navigation.js"></script>

            <!-- For Google font! -->
            <link rel="preconnect" href="https://fonts.googleapis.com">
            <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
            <script>
                function init() {
                    init_navigation();

            
// From module arrows import

            globals.arrows = new SimpleConnector()

// From arrows arrow function

    globals.arrows.connect(
        getElementById(2),
        getElementById(4),
        {
            parent: document.getElementById("deadlocks_problem"),
            color: "rgb(89, 89, 89, 1)",
label: "I am a arrow!",
line_kind: "orthogonal",
from_pos: {y:0,x:0.5,},
to_pos: {x:0.5,y:0,},

        },
    );


// From arrows arrow function

    globals.arrows.connect(
        getElementById(12),
        getElementById(17),
        {
            parent: document.getElementById("deadlock_cyclic_wait"),
            label: "fordert an",
to_pos: {x:0.5,y:0,},
line_kind: "orthogonal",
from_pos: {x:0.5,y:0,},
color: "rgb(89, 89, 89, 1)",

        },
    );


// From arrows arrow function

    globals.arrows.connect(
        getElementById(19),
        getElementById(14),
        {
            parent: document.getElementById("deadlock_cyclic_wait"),
            from_pos: {y:1,x:0.5,},
line_kind: "orthogonal",
label: "fordert an",
to_pos: {x:0.5,y:1,},
color: "rgb(89, 89, 89, 1)",

        },
    );




        }

            function onSlideChange() {
        // From module arrows import
globals.arrows.updateAll();


            }
        </script>
            
<!-- From arrows module -->
<script>function calculate_orthogonal_connection(start, startRel, end, endRel, lastWasVertical) {
    const direction = { x: Math.sign(startRel.x - 0.5), y: Math.sign(startRel.y - 0.5) };
    const delta = { x: end.x - start.x, y: end.y - start.y };
    console.log(start, delta, end);
    if (Math.abs(delta.x) < 0.1 && Math.abs(delta.y) < 0.1) {

        return [end];
    }
    if (direction.x == 0 && direction.y == 0) {
        if (Math.abs(delta.x) > Math.abs(delta.y)) {
            if (lastWasVertical == false) {
                direction.y = Math.sign(delta.y);
            } else {
                direction.x = Math.sign(delta.x);
            }
        } else {
            if (lastWasVertical == true) {
                direction.x = Math.sign(delta.x);
            } else {
                direction.y = Math.sign(delta.y);
            }
        }
    }
    if (direction.x != 0 && direction.y != 0) {
        if (Math.abs(startRel.x) > Math.abs(startRel.y)) {
            if (lastWasVertical == false) {
                direction.x = 0;
            } else {
                direction.y = 0;
            }
        } else {
            if (lastWasVertical == true) {
                direction.y = 0;
            } else {
                direction.x = 0;
            }
        }
    }
    const deltaLength = delta.x * delta.x + delta.y * delta.y;
    const minDistance = Math.sqrt(deltaLength) * 0.10;
    delta.x = Math.max(Math.abs(delta.x), minDistance);
    delta.y = Math.max(Math.abs(delta.y), minDistance);
    let point = { x: delta.x * direction.x + start.x, y: delta.y * direction.y + start.y };
    const newDelta = { x: end.x - point.x, y: end.y - point.y };
    if (deltaLength <= newDelta.x * newDelta.x + newDelta.y * newDelta.y) {
        point = { x: minDistance * direction.x + start.x, y: minDistance * direction.y + start.y };
    }
    const isVertical = direction.y != 0 && direction.x == 0;
    return [start, ...calculate_orthogonal_connection(point, { x: 0.5, y: 0.5 }, end, endRel, isVertical)];
}

function get_label_placement_for_orthogonal(points) {
    let minX = Number.MAX_SAFE_INTEGER;
    let maxX = Number.MIN_SAFE_INTEGER;
    let bestDelta = { x: 0, y: 0 };
    let point = points[0];
    for (let i = 0; i < points.length - 1; i++) {
        const delta = {
            x: points[i + 1].x - points[i].x,
            y: points[i + 1].y - points[i].y,
        };
        if (delta.x == 0) continue;
        if (minX > points[i].x) minX = points[i].x;
        if (maxX < points[i].x) maxX = points[i].x;
        if (minX > points[i + 1].x) minX = points[i + 1].x;
        if (maxX < points[i + 1].x) maxX = points[i + 1].x;
        if (delta.x > bestDelta.x) {
            bestDelta = delta;
            point = { x: points[i].x + delta.x * 0.5, y: points[i].y + delta.y * 0.5 };
        }
    }
    return point;
}

function create_line(options, points) {
    const result = [];
    switch (options.line_kind ?? 'direct') {
        case 'direct':
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('stroke', options.color || 'black');
            line.setAttribute('stroke-width', options.width || '2');
            result.push(line);
            break;
        case 'orthogonal':
            if (!points) {
                // Line will be created later
                break;
            }
            for (let i = 0; i < points.length - 1; i++) {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('stroke', options.color || 'black');
                line.setAttribute('stroke-width', options.width || '2');
                line.setAttribute('x1', points[i].x);
                line.setAttribute('y1', points[i].y);
                line.setAttribute('x2', points[i + 1].x);
                line.setAttribute('y2', points[i + 1].y);
                result.push(line);
            }
            break;
    }
    return result;
}

function create_label(text) {
    if (text == undefined) return undefined;
    const dom = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    dom.textContent = text;
    dom.setAttribute('text-anchor', 'middle');
    dom.style['transform-box'] = 'border-box';
    dom.style['transform-origin'] = 'center';
    return dom;
}

function create_svg_canvas() {
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.style.width = "100%";
    svg.style.height = "100%";
    svg.style.position = "absolute";
    svg.style.left = "0";
    svg.style.top = "0";
    return svg;
}

class SimpleConnector {
    constructor() {
        this.lines = [];
        window.addEventListener('resize', () => this.updateAll());
        window.addEventListener('scroll', () => this.updateAll(), true);
    }

    connect(from, to, options = {}) {
        const container = create_svg_canvas();
        if (options.parent) {
            options.parent.appendChild(container);
        } else {
            document.appendChild(container);
        }
        const line = {
            kind: options.line_kind ?? 'direct',
            from: { dom: from, pos: options.from_pos ?? { x: 0.5, y: 0.5 } },
            to: { dom: to, pos: options.to_pos ?? { x: 0.5, y: 0.5 } },
            dom: create_line(options),
            label_dom: create_label(options.label),
            parent: options.parent,
            options,
            container,
        };
        for (const dom of line.dom) {
            container.appendChild(dom);
        }
        if (line.label_dom) {
            container.appendChild(line.label_dom);
        }
        this.lines.push(line);
        this.updateLine(line);
        return line;
    }

    updateLine(line) {
        console.log("line", line);
        const posFrom = line.from.dom.getBoundingClientRect();
        const posFromRelative = line.from.pos;
        const posTo = line.to.dom.getBoundingClientRect();
        const posToRelative = line.to.pos;

        const parent = line.parent?.getBoundingClientRect() ?? { x: 0, y: 0 };

        const x1 = posFrom.left + posFrom.width * posFromRelative.x + window.scrollX - parent.x;
        const y1 = posFrom.top + posFrom.height * posFromRelative.y + window.scrollY - parent.y;
        const x2 = posTo.left + posTo.width * posToRelative.x + window.scrollX - parent.x;
        const y2 = posTo.top + posTo.height * posToRelative.y + window.scrollY - parent.y;

        const start = { x: x1, y: y1 };
        const end = { x: x2, y: y2 };
        switch (line.kind) {
            case 'direct': {
                line.dom[0].setAttribute('x1', start.x);
                line.dom[0].setAttribute('y1', start.y);
                line.dom[0].setAttribute('x2', end.x);
                line.dom[0].setAttribute('y2', end.y);
                if (line.label_dom) {
                    line.label_dom.setAttribute('x', (start.x + end.x) / 2);
                    line.label_dom.setAttribute('y', (start.y + end.y) / 2);
                    const deltaX = x2 - x1;
                    const deltaY = y2 - y1;
                    const rotation = Math.atan2(deltaY, deltaX);
                    line.label_dom.style.rotate = `${rotation}rad`;
                    line.label_dom.style.translate = `0px -7px`;
                }
                break;
            }
            case 'orthogonal': {
                const points = calculate_orthogonal_connection(start, posFromRelative, end, posToRelative, undefined);
                console.log(points, start, end);
                if (points.length == line.dom.length + 1) {
                    for (let i = 0; i < points.length - 1; i++) {
                        line.dom[i].setAttribute('x1', points[i].x);
                        line.dom[i].setAttribute('y1', points[i].y);
                        line.dom[i].setAttribute('x2', points[i + 1].x);
                        line.dom[i].setAttribute('y2', points[i + 1].y);
                    }
                } else {
                    for (const dom of line.dom) {
                        dom.remove();
                    }
                    line.dom = create_line(line.options, points);
                    for (const dom of line.dom) {
                        line.container.appendChild(dom);
                    }
                }
                if (line.label_dom) {
                    const point = get_label_placement_for_orthogonal(points);
                    line.label_dom.setAttribute('x', point.x);
                    line.label_dom.setAttribute('y', point.y);
                    line.label_dom.style.translate = `0px -7px`;
                }
                break;
            }
        }
    }

    updateAll() {
        for (const l of this.lines) {
            this.updateLine(l);
        }
    }
}
</script>


</head>
            <body onload="init()" onkeydown="keydown(event)">
<section id="deadlocks_problem" class="slide" data-step-count=0>
<div id="deadlocks_problem-title" class="label  " data-element-id="0">
<h1 class="label-header">
Deadlocks: Grundproblem</h1>
</div>
<div id="deadlocks_problem-base" class="custom-element DeadlockIcons  " data-element-id="9">
<div id="deadlocks_problem-base-amanda" class="custom-element Icon  " data-element-id="2">
<img id="deadlocks_problem-base-amanda-icon" class="image  " src="./pros-assets/amanda.png" data-element-id="1"/>
</div>
<div id="deadlocks_problem-base-bobbl" class="custom-element Icon  " data-element-id="4">
<img id="deadlocks_problem-base-bobbl-icon" class="image  " src="./pros-assets/bobbl.png" data-element-id="3"/>
</div>
<div id="deadlocks_problem-base-light" class="custom-element Icon  " data-element-id="6">
<img id="deadlocks_problem-base-light-icon" class="image  " src="./pros-assets/light.png" data-element-id="5"/>
</div>
<div id="deadlocks_problem-base-lift" class="custom-element Icon  " data-element-id="8">
<img id="deadlocks_problem-base-lift-icon" class="image  " src="./pros-assets/lift.png" data-element-id="7"/>
</div>
</div>
</section>
<section id="deadlock_cyclic_wait" class="slide" data-step-count=0>
<div id="deadlock_cyclic_wait-title" class="label  " data-element-id="10">
<h1 class="label-header">
Definition eines Deadlocks</h1>
<ol class="label-text">
  <li>
<p class="label-text">Zyklische Wartebedingung</p>
</ol>
</div>
<div id="deadlock_cyclic_wait-left" class="flex " data-element-id="15">
<div id="deadlock_cyclic_wait-left--12" class="custom-element Icon  " data-element-id="12">
<img id="deadlock_cyclic_wait-left--icon" class="image  " src="./pros-assets/amanda.png" data-element-id="11"/>
</div>
<div id="deadlock_cyclic_wait-left--14" class="custom-element Icon  " data-element-id="14">
<img id="deadlock_cyclic_wait-left--icon" class="image  " src="./pros-assets/lift.png" data-element-id="13"/>
</div>
</div>
<div id="deadlock_cyclic_wait-right" class="flex " data-element-id="20">
<div id="deadlock_cyclic_wait-right--17" class="custom-element Icon  " data-element-id="17">
<img id="deadlock_cyclic_wait-right--icon" class="image  " src="./pros-assets/light.png" data-element-id="16"/>
</div>
<div id="deadlock_cyclic_wait-right--19" class="custom-element Icon  " data-element-id="19">
<img id="deadlock_cyclic_wait-right--icon" class="image  " src="./pros-assets/bobbl.png" data-element-id="18"/>
</div>
</div>
</section>
</body></html>
